package pako;

import pako.Pako;
#if haxe4
import js.lib.Uint8Array;
import js.lib.ArrayBuffer;
#else
import js.html.Uint8Array;
import js.html.ArrayBuffer;
#end
import haxe.extern.EitherType;

typedef GZIPHeader = {
	/** `true` if compressed data believed to be text */
	@:optional var text:Bool;
	/** Modification time, unix timestamp */
	@:optional var time:Int;
	/** Operation system code */
	@:optional var os:Int;
	/** Array of bytes with extra data (max 65536) */
	@:optional var extra:Array<Int>;
	/** File name (binary string) */
	@:optional var name:String;
	/** Comment (binary string) */
	@:optional var comment:String;
	/** `true` if header crc should be added */
	@:optional var hcrc:Bool;
}

typedef DeflateOptions = {
	@:optional var level:Int;
	@:optional var windowBits:Int;
	@:optional var memLevel:Int;
	@:optional var strategy:Int;
	@:optional var chunkSize:Int;
	@:optional var raw:Bool;
	@:optional var gzip:Bool;
	@:optional var to:String;
	@:optional var dictionary:Dictionary;
	@:optional var header:GZIPHeader;
}

/**
	Generic JS-style wrapper for zlib calls.
	If you don't need streaming behavior - use more simple functions: `Pako.deflate`, `Pako.deflateRaw` and `Pako.gzip`.
**/
@:native('pako.Deflate')
extern class Deflate {
	/**
		Creates new deflator instance with specified params. Throws exception on bad params.
		Supported options: `level`, `windowBits`, `memLevel`, `strategy`, `dictionary`
		@see http://zlib.net/manual.html#Advanced

		Additional options, for internal needs:
			`chunkSize` - size of generated data chunks (16K by default)
			`raw` - do raw deflate
			`gzip` - create gzip wrapper
			`to` - if equal to 'string', then result will be "binary string" (each char code [0..255])
			`header` - Custom header for gzip
	**/
	public function new(?options:DeflateOptions);

	/**
		Error code after deflate finished. 0 (`Pako.Z_OK`) on success.
		You will not need it in real life, because deflate errors are possible only on wrong options
		or bad `onData` / `onEnd` custom handlers.
	**/
	public var err(default, null):Int;
	/** Error message, if `Deflate.err` != 0 */
	public var msg(default, null):String;
	/**
		Compressed result, generated by default `Deflate.onData` and `Deflate.onEnd` handlers.
		Filled after you push last chunk (call `Deflate.push` with `Pako.Z_FINISH` / `true` param)
		or if you push a chunk with explicit flush (call `Deflate.push` with `Pako.Z_SYNC_FLUSH` param).
	**/
	@:overload(var result:Array<Int>)
	public var result:Uint8Array;

	/**
		By default, stores data blocks in `chunks[]` property and glue those in `onEnd`.
		Override this handler, if you need another behavior.

		@param chunk - output data. Type of array depends on js engine support. When string output requested, each chunk will be string.
	**/
	@:overload(function(chunk:Uint8Array):Void{})
	@:overload(function(chunk:Array<Int>):Void{})
	public dynamic function onData(chunk:String):Void;

	/**
		Called once after you tell deflate that the input stream is complete (`Pako.Z_FINISH`)
		or should be flushed (`Pako.Z_SYNC_FLUSH`) or if an error happened.
		By default - join collected chunks, free memory and fill results / err properties.

		@param status - deflate status. 0 (`Pako.Z_OK`) on success, other if not.
	**/
	public dynamic function onEnd(status:Int):Void;

	/**
		Sends input data to deflate pipe, generating `Deflate.onData` calls with new compressed chunks.
		Returns `true` on success.
		The last data block must have mode `Pako.Z_FINISH` (or `true`). That will flush internal pending buffers and call `Deflate.onEnd`.
		For interim explicit flushes (without ending the stream) you can use mode `Pako.Z_SYNC_FLUSH`, keeping the compression context.

		On fail call `Deflate.onEnd` with error code and return `false`.

		We strongly recommend to use `Uint8Array` on input for best speed (output array format is detected automatically).

		For regular Array-s make sure all elements are [0..255].

		@param data - input data. Strings will be converted to utf8 byte sequence.
		@param mode - 0..6 for corresponding `Pako.Z_NO_FLUSH`..`Pako.Z_TREE` modes. See constants.
					Skipped or `false` means `Pako.Z_NO_FLUSH`, `true` means `Pako.Z_FINISH`.
	**/
	@:overload(function(data:Uint8Array, mode:EitherType<Int,Bool>):Bool{})
	@:overload(function(data:Array<Int>, mode:EitherType<Int,Bool>):Bool{})
	@:overload(function(data:ArrayBuffer, mode:EitherType<Int,Bool>):Bool{})
	public function push(data:String, mode:EitherType<Int,Bool>):Bool;
}